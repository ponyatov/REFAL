<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Refal on Java</title>
</head>

<body>

<h2 align="center">Записка к проекту<br>
&quot;Реализация Рефала на Java-платформе&quot;</h2>
<h2>1. Общие принципы</h2>
<h4>1.1. Цель проекта</h4>
<p>Главная цель новой реализации Рефала -- исправить
основной недостаток существующих: старые системы были
в основном предназначены для создания замкнутых
программ на Рефале, вызываемых как готовое приложение
с командной строки. Средства интеграции с другими
языками были развиты слабо. Лишь одна из систем -- Рефал-2
(переживавшая 3 &quot;инкарнации&quot;) имела достаточно
хорошо документированный интерфейс с Фортраном (на
БЭСМ-6), PL/I (на IBM/360) или С (на IBM/PC). Однако, тот &quot;низкоуровневый&quot;
стиль интерфейса не удовлетворяет требований
сегодняшнего дня: он был рассчитан на то, что программа
на языке &quot;низкого уровня&quot; подстраивается под
понятия реализации Рефала &quot;ради эффективности&quot;
последнего. Теперь тех требований &quot;эффективности&quot;
нет. Современный стиль: &quot;все во имя человека&quot;, то
есть используем мощность компьютеров для создания
удобств разработчикам, для удешевления их труда.</p>
<p>В современном мире доминируют объектно-ориентированные
языки. Именно с ними и надо интегрироваться. Рефал
должен стать инструментом программирования отдельных
(&quot;интеллектуальных&quot;) подсистем в рамках больших
проектов, ведущихся на Яве, C# и т.п.</p>
<p>Главным фактором, определяющим выбор решений, должен
стать следующий:</p>
<blockquote>
  <p>Как можно более &quot;прозрачная&quot;, &quot;бесшовная&quot;
  (&quot;seamless&quot;) интеграция с языком Java. Это означает, что
  описание интерфейса Рефал-Java должно быть как можно
  более простым, чтобы программистам было легко
  вызвать функцию на Рефале из программы на Яве и
  наоборот.</p>
</blockquote>
<p>Второе по важности требование проекта:</p>
<blockquote>
  <p>Основная часть реализации Рефала, после которого ею
  может пользоваться квалифицированный программист на
  Рефале и Яве, должна быть сделана быстро (за один-два
  месяца). После этого система будет развиваться дальше.</p>
</blockquote>
<p>Стороны отдают себе отчет, что в результате первого
этапа полноценная система еще не появится и
потребуются дальнейшие вложения средств и сил. Было бы
очень выгодным организовать развитие системы в режиме
open-source. Но это также требует определенных
организационных усилий.</p>
<p>См. подробнее в разделе &quot;Состав Рефал-системы&quot;.</p>
<h3>1.2. Почему Рефал?</h3>
<p>Выбор языка для разработки определенного класса
приложений -- серьезное бизнес-решение, с анализом
преимуществ и недостатков. Безусловного и идеального
решения здесь нет. Проблема выбора Рефала усложняется
тем, что подходящей стабильной реализации,
поддерживаемой крупной софтверной фирмой нет, и нужно
изготавливать свою систему. Перечислим факторы,
которые, на наш взгляд, надо учитывать.</p>
<p>В 70-е годы Рефал был уникален в своем классе.
Ближайшим родственником был Лисп, который по
сравнению с Рефалом -- язык низкого уровня (к нему
неплохо подходит метафора &quot;рекурсивный язык
ассемблера&quot;). Любители низкого уровня выбирали Лисп
(а в 80-е годы его потомка -- язык Scheme), а те, кто
предпочитал думать, а не кодировать, -- Рефал.
Родственные высокоуровневые языки (макро-расширения
Лиспа, Snobol и др.) заметно отставали от Рефала по
качеству.</p>
<p>В 80-е годы ситуация изменилась. Появилась плеяда
функциональных языков высокого уровня: Hope, Miranda, ML (потом
он SML, Standard ML), Caml, Haskell. Из этих языков наибольший
интерес представляют SML, Caml, Haskel. Их общая черта --
статическая типизация, в то время как Лисп и Рефал были
нетипизированными (статически), точнее:
типизированными динамически, то есть типы данных
хранились в их представлении и проверялись во время
счета. Интересно, что новых нетипизированных
функциональных языков не появилось.</p>
<p>Общими у этих языков являются такие свойства:</p>
<ul>
  <li>это функциональные языки</li>
  <li>основные данные -- деревья; произвольные графы --
    дополнительный конструкт</li>
</ul>
<p>В некотором смысле родственниками Рефала можно
также считать языки логического программирования --
Пролог и др., а также активно развивающиеся в последнее
время функционально-логические. Однако, они, с нашей
точки зрения, перегружены конкретными средствами
решения обратной задачи, которые далеко не всегда
нужны, а если нужны, то другие. Рефал не содержит
подобных механизмов, однако по сравнению с
упомянутыми функциональными языками в нем имеются
средства организации перебора, включая
отождествление по сложным образцам. Тем самым он
выполняет роль &quot;функционального языка,
продвинутого в сторону языков логического
программирования&quot;.</p>
<p><i>Таблица</i>. Классификация функциональных языков по
двум ортам: высокий / низкий уровень, типизированный /
нетипизированный:</p>
<div align="center">
  <center>
  <table border="1" cellpadding="5" cellspacing="0">
    <tr>
      <td align="center">&nbsp;</td>
      <td align="center">типизированный</td>
      <td align="center">нетипизированный</td>
    </tr>
    <tr>
      <td align="center">высокий<br>
        уровень</td>
      <td align="center">SML, Caml,<br>
        Haskel и др.</td>
      <td align="center">Рефал</td>
    </tr>
    <tr>
      <td align="center">низкий<br>
        уровень</td>
      <td align="center">-</td>
      <td align="center">Lisp,<br>
        Scheme</td>
    </tr>
  </table>
  </center>
</div>
<p>Типизированные языки предпочтительнее для больших
проектов, когда отладка становится особенно
затруднительной и ошибки, вылавливаемые типизацией,
заметно увеличивают скорость разработки и удешевляют
ее. А в небольших или в хорошо структурированных
проектах, когда каждую подсистему разумного размера
можно разрабатывать и мыслить отдельно, более
популярны нетипизированные или слабо-типизированные
языки т.н. <i>scripting languages</i>: Visual Basic, JavaScript, Tcl (последний
особенно интересен для сравнения с Рефалом) и др. Lisp и
Scheme также выполняют роль <i>scripting languages</i> (достаточно
вспомнить знаменитый редактор Emacs, расширяемый на
Лиспе). Рефал также хорошо подходит на роль scripting language.</p>
<p>И наконец, важнейшим бизнес-фактором является выбор
между &quot;чужым&quot; и &quot;своим&quot;: между хорошо-отработанным
&quot;фирменным&quot; языком и реализацией языка почти
одновременно с его внедрением в тесном контакте
разработчиков приложения и языка. Это самый рисковый
аспект. Здесь можно учитывать такие принципы (в равной
мере пригодные для разработки как software, так и hardware):</p>
<ol>
  <li>&quot;чужое&quot; должно быть отличным, понятным и
    работающим без контакта с авторами; &quot;свое&quot;
    может быть &quot;сырым&quot;, так как авторы, которые
    берут на себя проблемы, рядом</li>
  <li>если нет подходящего &quot;чужого&quot;, хорошо
    проверенного в приложениях аналогичного класса,
    выгоднее делать &quot;свое&quot;, чем мучаться с &quot;чужим&quot;,
    которое невозможно подстроить под себя.</li>
</ol>
<p>Интересно, что факторы &quot;чужой / свой&quot;
коррелируют с &quot;типизированный / нетипизированный&quot;.
Реализации (особенно компиляторы) нетипизированных
языков заметно проще, чем типизированных, а с учетом
того, что можно воспользоваться такими развитыми
платформами как Java или MS.Net, воплотить Рефал будет
намного дешевле чем скажем, SML (особенно без учета
полной интеграции в IDEs и богатых средств отладки,
которые можно дорабатывать во вторую очередь).</p>
<h3>1.3. Задел</h3>
<p>Информация по Рефалу имеется на сайте:</p>
<ul>
  <li><a href="http://www.refal.com">http://www.refal.com</a></li>
  <li><a href="http://www.refal.net">http://www.refal.net</a></li>
  <li><a href="http://www.refal.org">http://www.refal.org</a></li>
  <li><a href="http://www.refal.ru">http://www.refal.ru</a></li>
</ul>
<p>(это зеркала одного и того же сайта) и списках
рассылки <a href="mailto:refal@botik.ru">refal@botik.ru</a> и <a href="mailto:refal-plus@botik.ru">refal-plus@botik.ru</a>,
архивируемых здесь:</p>
<ul>
  <li><a href="http://www.botik.ru/mail-archive/refal/">http://www.botik.ru/mail-archive/refal/</a></li>
  <li><a href="http://www.botik.ru/mail-archive/refal-plus/">http://www.botik.ru/mail-archive/refal-plus/</a></li>
</ul>
<p>На настоящий момент имеются такие реализации Рефала
на Intel-платформах:</p>
<ul>
  <li><b>Рефал-2 </b>А.Красовского (1991). Система получена
    переносом на С с PLI системы Рефал-2 С.Романенко для
    IBM/360 (1984). Имеет полную документацию, включая
    описание интерфейса с С. Реализация использует
    линейные двусвязные списки. Есть динамические
    переменные (&quot;ящики&quot;), ссылки на них и сборка
    мусора. С нашей точки зрения, Рефал-2 как язык &quot;морально
    устарел&quot;.</li>
  <li><b>Рефал-5 </b>В. и Д.Турчиных (1987). Имеет описание на
    английском и русском языках (на сайте <a href="http://www.refal.org">www.refal.org</a>).
    Система &quot;замкнутая в себе&quot;. Реализация
    использует линейные двусвязные списки.
    Динамических переменных и ссылок на них нет.
    Использовался и используется для реализации
    суперкомпиляторов Рефала В.Турчиным и А.Немытых.
    Язык Рефал-5 является концептуальной основой Рефала
    Плюс и Рефала-6.</li>
  <li><b>Рефал Плюс</b> С.Романенко и Р.Гурина (1990). Самое
    большое &quot;концептуально-замкнутое&quot; расширение
    Рефала с целью изобразимости на входном языке
    оптимизаций и суперкомпиляции. Реализация
    использует связные участки памяти и сборку мусора.
    Есть динамические переменные (&quot;ящики&quot;). Входной
    язык и библиотека хорошо документированы (есть
    остатки тиража книги). Однако, интерфейса с С нет. Это
    главный минус.</li>
  <li><b>Рефал-6 </b>Аркадия Климова (199x). Впитал в себя опыт
    Рефала-5 и Рефала Плюс. Представление данных --
    двусвязные списки и деревья (&quot;подвешенные скобки&quot;).
    Есть динамические переменные (&quot;ящики&quot;), но
    сборки мусора нет; память чистится по обнулению
    счетчиков ссылки. Автор доступен. Это главный плюс.:-)</li>
</ul>
<p>За основу новой реализации Refal-on-Java будет взята
система Рефал-6. Ее входной язык близок к Рефалу 5 и
Рефалу Плюс, но с некоторыми отличиями. Ее компилятор
написан на Рефале-6. Синтаксис языка на первом этапе
предлагается менять минимально. На следующих этапах
возможно развитие языка. Сразу понадобится добавить
понятия модульности Явы (пакеты; именование функций
составными именами через точку). Подробности см. ниже.</p>
<h3>1.4. Место Рефала-на-Java в объектно-ориентированной
среде</h3>
<p>Языки, интегрированные в общую объектно-ориентированную
среду, характеризуются следующими свойствами:</p>
<ul>
  <li>Языки-поставщики: языки, на которых можно
    определить все (или хотя бы большинство) объектно-ориентированные
    сущности -- в первую очередь, классы, -- которые потом
    можно использовать из программ на других языках.</li>
  <li>Языки-потребители: языки, на которых можно
    использовать объектно-ориентированные сущности,
    определенные на других языках.</li>
</ul>
<p>К новой реализации Рефала не предъявляется
требований, чтобы он удовлетворял этим свойствам в
полной мере. Взаимодействие программ на Рефале и на Java
будет проходить через средства, которые лежат в &quot;пересечении&quot;
их понятий:</p>
<ul>
  <li>&nbsp;определяем представление Рефал-данных в Java:
    <ul>
      <li>рефал-терм = Object</li>
      <li>рефал-выражение = Object[]</li>
    </ul>
  </li>
  <li>в методы какого вида отображаются функции Рефала</li>
  <li>соглашение о том, какие методы можно вызывать из
    Рефала непосредственно (статические, с аргументами
    из значениями определенного вида)</li>
</ul>
<p>Подробнее см. ниже в разделе &quot;Технические решения&quot;.</p>
<p>В будущем возможно развитие Рефала в сторону все
более полного языка-потребителя вплоть до вызова
виртуальных методов в объектах.</p>
<h3>1.5. Состав Рефал-системы</h3>
<p>Полномасштабная Рефал-система должна состоять из
следующих подсистем:</p>
<dl compact>
  <dt>(+)</dt>
  <dd>Компилятор с Рефала в Яву</dd>
  <dt>(+)</dt>
  <dd>Runtime
    <dl compact>
      <dt>(+)</dt>
      <dd>Подпрограммы, используемые при реализации
        семантики языка</dd>
      <dt>(<small>+</small>-)</dt>
      <dd>Библиотека функций для Рефала</dd>
      <dt>(<small>+</small>-)</dt>
      <dd>&quot;Пакетные&quot; средства отладки</dd>
    </dl>
  </dd>
  <dt>(–)</dt>
  <dd>Погружение в IDE
    <dl compact>
      <dt>(+)</dt>
      <dd>Просто: Вызов компилятора и счета из редакторов</dd>
      <dt>(–)</dt>
      <dd>Сложно: Редактирование с подсказками (вариантов
        функций на Рефале и других языках)</dd>
      <dt>(–)</dt>
      <dd>Средне: Диалоговая система отладки</dd>
    </dl>
  </dd>
  <dt>(-<small>+</small>)</dt>
  <dd>Документация
    <dl compact>
      <dt>(<small>+</small>-)</dt>
      <dd>По инсталляции и использованию системы
        <ul>
          <li>README</li>
          <li>Getting Started</li>
        </ul>
      </dd>
      <dt>(<small>+</small>-)</dt>
      <dd>По входному языку</dd>
      <dt>(<small>+</small>-)</dt>
      <dd>По библиотеке функций для Рефала</dd>
      <dt>(<small>+</small>-)</dt>
      <dd>По интерфейсу с Явой</dd>
      <dt>(–)</dt>
      <dd>Tutorials</dd>
    </dl>
  </dd>
</dl>
<p>Знаками (+), (<small>+</small>-), (-<small>+</small>), (–) помечены 4
уровня приоритетов. На 1-ой очереди делаются только (+), (<small>+</small>-),
причем (<small>+</small>-) в &quot;сыром&quot; виде.</p>
<p>На первом этапе ключевым словом является &quot;минимальный&quot;.
Будут реализованы:</p>
<ul>
  <li>Компилятор с Рефала-6 в Яву с минимальными
    расширениями языка, чтобы подстроить модульность к
    Яве</li>
  <li>Минимальная библиотека (чтобы дать какие-то
    средства программирования первых задач и
    взаимодействия с внешним миром и отработать
    интерфейс Рефал-Ява)</li>
  <li>Минимальное средство заказа трассировки:
    компилятору указываем имена функций, для которых
    вставить печать при входе и/или при выходе.</li>
</ul>
<h2>&nbsp;</h2>
<h2>2. Технические решения</h2>
<p>Решения, перечисленные ниже, -- это ориентировочный
проект. Они могут меняться в некоторых деталях, но вряд
ли изменятся по существу. Их фиксация произойдет
только после того, как заработает реализация и
начнется эксплуатация. Но даже после этого возможны
изменения по взаимному решению разработчиков и
заказчиков.</p>
<h4>2.1 Входной язык</h4>
<p>За основу берется синтаксис и семантика Рефала-6.
Вносятся некоторые недостающие элементы Рефала Плюс.
Делаются также некоторые расширения, продиктованные
взаимодействием с языком Java.</p>
<h4>2.2 Модули</h4>
<p>Программа на Рефале состоит из модулей, каждый
модуль содержит набор именованных сущностей, например,
функций (а также, возможно, ящиков, векторов, таблиц,
каналов и т.п.)</p>
<p>Модуль в Рефале описывается парой файлов: rfi-файл
интерфейса и rfj-файл определений (как в Рефале Плюс).
Файл интерфейса содержит объявления сущностей,
доступных из других модулей.</p>
<p>Если интерфейсный файл отсутствует, то считается,
что он содержит одно объявление:</p>
<p>&nbsp;<font face="Courier New">&nbsp;&nbsp; $Func main e:String=;</font></p>
<p>Из других модулей сущности доступны по полному имени
вида &lt;имя-модуля&gt;.&lt;простое-имя-сущности&gt;.
Возможен также доступ по короткому имени &lt;простое-имя-сущности&gt;,
если в теле использующего файла определений имеется
предложение</p>
<p><font face="Courier New">$use &lt;имя-модуля&gt;...;</font>&nbsp; -- как в
Рефале Плюс</p>
<p>Имена модулей в свою очередь тоже могут быть
составными, то есть иметь префикс, отделенный точкой.
Префикс тоже может быть составным.</p>
<p>Предложение вида (может находится только в начале
файла определений)</p>
<p><font face="Courier New">$import &lt;префикс&gt;.&lt;простое-имя-модуля&gt;;</font></p>
<p>делает возможным &lt;простое-имя-модуля&gt; в
дальнейшем записывать без префикса. Аналогично,
предложение</p>
<p><font face="Courier New">$import &lt;префикс&gt;.*;</font></p>
<p>дает возможность записывать простым образом все
имена модулей, имеющие данный префикс.</p>
<p>Чтобы данный модуль имел данный префикс, надо в
начале модуля написать:</p>
<p><font face="Courier New">$package &lt;prefix&gt;;</font></p>
<p>Префикс определяет путь в структуре каталогов от
некоторого корня к каталогу, в котором лежат файлы
интерфейса и определений данного модуля.</p>
<p><b><i>1-я очередь</i>: </b>Нет интерфейсных файлов и нет
предложения $use, но для импорта есть предложение вида</p>
<p><font face="Courier New">$from &lt;имя-модуля&gt; $import &lt;простое-имя-сущности&gt;,...;</font></p>
<p>которое дает возможность использовать в теле модуля
упомянутые имена сущностей (функций, статических
символов-ссылок и т.п.) без указания имени модуля. Для
экспорта используется предложение:</p>
<p><font face="Courier New">$export &lt;простое-имя-сущности&gt;...;</font></p>
<h4><i>Реализация</i></h4>
<p>Принципы компиляции:</p>
<ol>
  <li>Компилятор получает задание на компиляцию каждого
    модуля (автоматической подкомпиляции используемых
    модулей не производится). В командной строке
    компиляции может быть указано несколько имен
    модулей, в том числе посредством wildcards.</li>
  <li>Модуль отображается в одноименный Java-класс.
    Префикс модуля - в имя Java-пакета.</li>
  <li>Компилятор переводит модуль в Java-класс, имея на
    входе оба файла самого этого модуля и интерфейсные
    файлы других модулей, которые в нем используются.
    Никакие иные данные компилятором не используются. (В
    1-й очереди rfj-файл компилируется совершенно
    независимо).</li>
  <li>
    <p>Предложения $import и $prefix переводятся один к одному (без
    знака $) в начало файла на java. Кроме того, добавляется
    предложение import refal;</p>
  </li>
</ol>
<p>Таким образом, пользователь может сам написать
модуль на Java, снабдив его файлом интерфейса, и его
статические методы и объекты будут доступны из Рефала.
(В 1-й очереди интерфейсные сущности могут включать
только статические методы сигнатурой (Object[]) -&gt; Object[] и
статические поля с объектом в качестве значения).</p>
<p>Каждая объявленная сущность модуля, кроме функций,
отображается в одноименное статическое поле класса.
Функции отображаются в одноименные статические
методы.</p>
<p>Чтобы экспортировать функцию как объект, ее нужно <b>дополнительно</b>
описать предложением</p>
<p>&nbsp;<font face="Courier New">&nbsp;&nbsp; $Func &lt;Name&gt;;</font></p>
<p>тогда в других модулях доступна ссылка на эту
функцию как символ:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="Courier New">*Name</font>&nbsp;&nbsp;&nbsp;
-- как в Рефале-6<br>
или<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="Courier New">&amp;Name</font>&nbsp;&nbsp;&nbsp;
-- как в Рефале Плюс</p>
<p>(В 1-й очереди этот вид экспорта будет порождаться по
умолчанию для всех функций, упомянутых в предложении
$export).</p>
<p>Аналогичные ссылки на локальные функции модуля
можно вводить без дополнительных объявлений.</p>
<p>Экспортируемые имена объявляются public, остальные -
private.</p>
<h4>2.3 Функции</h4>
<p>Функция может иметь предобъявление вида:</p>
<p><font face="Courier New">&nbsp;&nbsp;&nbsp; $Func &lt;name&gt; &lt;входной формат&gt;
= &lt;выходной формат&gt;;</font></p>
<p>или, в случае откатной функции:</p>
<p><font face="Courier New">&nbsp;&nbsp;&nbsp; $Func? &lt;name&gt; &lt;входной формат&gt;
= &lt;выходной формат&gt;;</font></p>
<p>Если таковое отсутствует, то считается, что функция
имеет объявление</p>
<p>&nbsp;<font face="Courier New">&nbsp;&nbsp; $Func? &lt;name&gt; e=e;</font></p>
<p>(Внимание: здесь имеется отличие от Рефала Плюс, где
по умолчанию функции безоткатные. Это связано с тем,
что основу нашего языка составляет Рефал-6, где все
функции откатные. Так удобнее при той семантике знака
'=', которая имеет место в Рефале-6).</p>
<p>В 1-й очереди возможности описывать формат не будет,
все функции будут считаться откатными с форматом e=e.
Входной функцией считается функция&nbsp;</p>
<p><font face="Courier New">$Func? Main e=e;</font></p>
<p><b><i>Реализация</i></b></p>
<p>На основе формата вычисляется сигнатура метода на
Java. Каждой переменной входного формата соответствует
один параметр. Тип параметра определяется типом
переменной и возможным дополнительным спецификатором,
например:</p>
<table border="1" width="61%" align="center">
  <tr>
    <td width="50%" align="center">Переменная формата</td>
    <td width="50%" align="center">Тип параметра</td>
  </tr>
  <tr>
    <td width="50%" align="center">e</td>
    <td width="50%" align="center">Object[]</td>
  </tr>
  <tr>
    <td width="50%" align="center">
      <p align="center">t</td>
    <td width="50%" align="center">Object</td>
  </tr>
  <tr>
    <td width="50%" align="center">s</td>
    <td width="50%" align="center">Object</td>
  </tr>
  <tr>
    <td width="50%" align="center">e:SomeClass</td>
    <td width="50%" align="center">SomeClass[]</td>
  </tr>
  <tr>
    <td width="50%" align="center">t:SomeClass</td>
    <td width="50%" align="center">SomeClass</td>
  </tr>
  <tr>
    <td width="50%" align="center">s:int</td>
    <td width="50%" align="center">int</td>
  </tr>
  <tr>
    <td width="50%" align="center">e:float</td>
    <td width="50%" align="center">float[]</td>
  </tr>
</table>
<p>Для выходного формата тип результата определяется
так:</p>
<ol>
  <li>Если в формате нет ни одной переменной, то void (для
    откатной функции - boolean)</li>
  <li>Если в формате ровно одна переменная, то тип
    результата определяется по таблице. Для откатных
    функций неудача кодируется как null, если таковое
    значение для соответствующего типа допустимо, иначе
    - откаты не допускаются.</li>
  <li>Если в выходном формате несколько переменных, то
    все они объединяются в один массив типа Object[]. Длина
    массива равна количеству переменных. Примитивные
    типы заменяются оберточными типами (Integer, Double,...)</li>
</ol>
<p>Если в интерфейсном файле для функции &lt;name&gt; имеется
дополнительное объявление</p>
<p><font face="Courier New">$Func &lt;name&gt;;</font></p>
<p>или имя внутренней функции используется в качестве
символа-ссылки, то дополнительно к методу порождается
одноименное поле</p>
<p><font face="Univers Condensed">public/private refal.Function &lt;name&gt; =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new
refal.Function(&quot;&lt;full-name&gt;&quot;) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Object[] eval(Object[] e) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return &lt;name&gt;(e);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></p>
<p><font face="Univers Condensed">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
}</font></p>
<p>Если функция имеет объявление формата отличное от</p>
<p><font face="Courier New">$Func? &lt;name&gt; e=e;</font></p>
<p>то в тело виртуального метода eval вставляются
дополнительные операторы преобразования формата,
например:</p>
<p><font face="Courier New">$Func foo s:int: e = s:int;</font></p>
<p><font face="Univers Condensed">public refal.Function &lt;name&gt; =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new
refal.Function(&quot;module.foo&quot;) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Object[] eval(Object[] e) {</font></p>
<p><font face="Univers Condensed">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Integer s1 = (Integer) e[0];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Object[] e2 = new Object[e.length-1];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
System.arraycopy(e,1,e2,0,e.length-1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return new Object[] {new Integer(foo(s1,e2))};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></p>
<p><font face="Univers Condensed">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}<br>
}</font></p>
<p>1-я очередь: если в модуле определена функция Main, то
автоматически добавляется метод:</p>
<p><font face="Univers Condensed">public static void main(String[] args) { Main(args); }</font></p>
<p>Таким образом функция Main принимает выражение,
термами которого являются последовательные параметры
командной строки, каждый параметр - слово.</p>
<h4>2.4 Данные</h4>
<p>Выражение есть последовательность термов. Терм есть
либо выражение в скобках, либо символ. Символ есть:
литера, число, слово, символ-ссылка. Еще теперь
появляется символ null.</p>
<p>Статические символы-ссылки описываются
предложением вида</p>
<p>$&lt;тип-ссылки&gt; &lt;символ&gt;,... ;</p>
<p>Например:</p>
<p>$BOX A,B,C;</p>
<p><b><i>Реализация</i></b></p>
<p>Выражение отображается на массив типа java.lang.Object[].
Произвольный терм - на java.lang.Object. Выражение в скобках -
опять-таки массив объектов. Неоднозначность снимается
правилом: на верхнем уровне скобки снимаются. Надеюсь,
не запутаемся.</p>
<p>Литеры представляются объектами типа java.lang.Character.&nbsp;</p>
<p>Слова - java.lang.String.&nbsp;</p>
<p>Числа - Integer, Long, Float, Double, BigInteger, BigDecimal. Запись констант
можно сделать как в java (с L на конце - Long, иначе Integer, с f -
Float, иначе - Double), для перевода в BigInteger, BigDecimal
используется явная функция. Встроенные операции ADD, SUB,
MUL, DIV, REM применимы равно к любым видам чисел.</p>
<p>В качестве символов-ссылок могут использоваться
любые java-объекты (не массивы).</p>
<p>Тип ссылки - это класс на java. Для каждого символа
компилятор создает одноименное статическое поле
указанного типа и инициализирует его через
конструктор без параметров, который в этом классе
должен быть.</p>
<p>Встроенные классы BOX, ТАBLE ... находятся в пакете refal.
Поэтому их тип может записываться всегда без префикса.</p>
<h4>2.5 Пример компиляции (для 1-й очереди)</h4>
<p>Возмем такой код на рефале:</p>
<p><b><i>Файл Sequence.rfj:</i></b></p>
<p><font face="Courier New">$from STDIO $import PRINTLN</font></p>
<p><font face="Courier New">PurgeEqual {<br>
e1 e2, e2: $r e3 e3 e4 = &lt;PurgeEqual e1 e3&gt;;<br>
e1 = e1;<br>
}<br>
<br>
Main e1 = &lt;PRINTLN &lt;PurgeEqual e1&gt;&gt;;</font></p>
<p>А вот как он будет странслирован в java:</p>
<p><b><i>Файл Sequence.java:</i></b></p>
<pre>
public class Sequence {

// PurgeEqual {
//   e1 e2, e2: $r v3 v3 e4 = &lt;PurgeEqual e1 e4&gt;;
//   e1 = e1;
// }

static Object[] PurgeEqual (Object[] e0) {
    int len0 = e0.length;
    for (int i1=0; i1&lt;=len0; i1++) {
        int len2 = len0-i1;
        for(int i3 = len2/2; i3&gt;0; i3--) {
            if (Lang.exprsEqual(e0,i1,e0,i1+i3,i3)) {
                int i4 = 2*i3;
                int len4 = len2 - i4;
                int len5 =  i1 + len4;
                Object[] e5 = new Object[len5];
                System.arraycopy(e0,0,e5,0,i1);
                System.arraycopy(e0,i1+i4,e5,i1,len4);
                Object[] e6 = PurgeEqual(e5);
                return e6;
                }
            }
        }
    return e0;
    }

// Main e1 = &lt;PRINTLN &lt;PurgeEqual e1&gt;&gt;;

static private Object[] Main(Object[] e1) {
    Object[] e2 = PurgeEqual(e1);
    return STDIO.PRINTLN(e2);
    }

public static void main(String[] args) { Main(args); }
}</pre>

</body>

</html>
